import{QueryBuilder as u}from"./QueryBuilder.js";let l={};const a=class a{constructor(t={}){this.populate(t)}static get connection(){return this._connection}populate(t){const e=this;for(let r in t)typeof t[r]!="function"&&(e[r]=t[r])}_beforeSave(){}_afterSave(){}static create(t){var e=this.getTableConnection();let r=new this;r.populate(t),r._beforeSave(),r.hasOwnProperty("created")&&(r.created=new Date);let n=this._getSaveData(r,t);return e.put(n).then(i=>(r.id=i,this.setLastInsert(i),r._afterSave(),r))}static _getSaveData(t,e){let r={};return Object.keys(t).map(i=>r[i]=t[i]),r}save(t){const e=this.constructor;var r=e.getTableConnection();let n,i;return this._beforeSave(),this.id?(i=e._getSaveData(this,t),n=r.update(this.id,this)):(this.hasOwnProperty("created")&&(this.created=new Date),i=e._getSaveData(this,t),delete i.id,n=r.add(i),n.then(s=>{this.id=s,e.setLastInsert(s)})),this._afterSave(),n}delete(){var t=this.constructor.getTableConnection();return t.delete(this.id)}static _where(t,e){if(e)for(let r in e)t.where(r).equals(e[r])}static find(t){var e=this.getTableConnection();return e.get(t)}static first(t){let e=this.getQueryBuilder();return this._where(e,t),e.first()}static last(t){let e=this.getQueryBuilder();return this._where(e,t),e.last()}static count(t){var e=this.getQueryBuilder();return this._where(e,t),e.count()}static countIn(t,e,r){var n=this.getTableConnection();let i=n.where(t).anyOf(e);return r&&(i=i.and(r)),i.count()}static fetch(t,e,r,n,i){if(r&&e){var s=(r-1)*e;t.offset(s)}return e&&t.limit(e),n&&t.sortBy(n,i),t.all()}static all(t,e,r,n,i){let s=t?this.where(t):this.getQueryBuilder();return this.fetch(s,e,r,n,i)}static filter(t){return this.getQueryBuilder().filter(t)}static where(t){const e=this.getQueryBuilder();return e.where(t),e}static whereIn(t,e){return this.getQueryBuilder().where(t).anyOf(e).all()}static whereNotIn(t,e){return this.getQueryBuilder().where(t).noneOf(e).all()}static insertAll(t){var e=this.getTableConnection();let r=e==null?void 0:e.bulkPut(t);return r==null||r.then(n=>{this.setLastInsert(n)}),r}static updateAll(t){var e=this.getTableConnection();return e.bulkPut(t)}static deleteAll(t){var e=this.getTableConnection();return e.bulkDelete(t)}static truncate(){var t=this.getTableConnection();return t.clear()}static setLastInsert(t){var e=this.getTableName();l[e]=t}static getLastInsert(){var t=this.getTableName();return l[t]}static setTableConnection(t){this._connection=t}static getTableConnection(){if(!this._connection)throw"Table connection is not set. Do this with the setTableConnection method";return this._connection}static getQueryBuilder(){const t=this.getTableConnection();return new u(t)}static query(){return this.getQueryBuilder()}static getSchema(){return[]}static getColumns(){let t=this.getTableConnection();if(!t)return[];let e=[t.schema.primKey.name];return t.schema.indexes.map(r=>{r.compound||e.push(r.name)}),e}static setTableName(t){this.tableName=t}static getTableName(){return this.tableName}static getNumberValue(t){return typeof t=="number"?t:typeof t=="boolean"?t?1:0:typeof t=="string"?Number(t):isNaN(t)?0:Number(t)}};a.tableName="";let c=a;export{c as Model};
