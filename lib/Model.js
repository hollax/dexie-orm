import{QueryBuilder as c}from"./QueryBuilder.js";let l={};const a=class a{constructor(t={}){this.populate(t)}static get connection(){return this._connection}populate(t){const e=this;for(let r in t)typeof t[r]!="function"&&(e[r]=t[r]);return this}_beforeSave(){}_afterSave(){}static create(t){var e=this.getTableConnection();let r=new this;r.populate(t),r._beforeSave(),r.hasOwnProperty("created")&&(r.created=new Date);let i=this._getSaveData(r,t);return e.put(i).then(n=>(r.id=n,this.setLastInsert(n),r._afterSave(),r))}static _getSaveData(t,e){let r={};return Object.keys(t).map(n=>r[n]=t[n]),r}save(t){const e=this.constructor;var r=e.getTableConnection();let i,n;return this._beforeSave(),this.id?(n=e._getSaveData(this,t),i=r.update(this.id,this)):(this.hasOwnProperty("created")&&(this.created=new Date),n=e._getSaveData(this,t),delete n.id,i=r.add(n),i.then(s=>{this.id=s,e.setLastInsert(s)})),this._afterSave(),i}delete(){var t=this.constructor.getTableConnection();return t.delete(this.id)}static _where(t,e){let r=t;if(e)for(let i in e)r=t.where(i).equals(e[i]);return r}static async find(t){var e=this.getTableConnection();return e.get(t)}static first(t){let e=this.getQueryBuilder();return this._where(e,t),e.first()}static last(t){let e=this.getQueryBuilder();return this._where(e,t),e.last()}static count(t){var e=this.getQueryBuilder();return this._where(e,t),e.count()}static countIn(t,e,r){var i=this.getTableConnection();let n=i.where(t).anyOf(e);return r&&(n=n.and(r)),n.count()}static fetch(t,e,r,i,n){if(r&&e){var s=(r-1)*e;t.offset(s)}return e&&t.limit(e),i&&t.sortBy(i,n),t.all()}static all(t,e,r,i,n){let s=this.getQueryBuilder();return t&&(s=this._where(s,t)),this.fetch(s,e,r,i,n)}static filter(t){return this.getQueryBuilder().filter(t)}static where(t){const e=this.getQueryBuilder();return e.where(t),e}static whereIn(t,e){return this.getQueryBuilder().where(t).anyOf(e).all()}static whereNotIn(t,e){return this.getQueryBuilder().where(t).noneOf(e).all()}static insertAll(t){var e=this.getTableConnection();let r=e==null?void 0:e.bulkPut(t);return r==null||r.then(i=>{this.setLastInsert(i)}),r}static updateAll(t){var e=this.getTableConnection();return e.bulkPut(t)}static deleteAll(t){var e=this.getTableConnection();return e.bulkDelete(t)}static truncate(){var t=this.getTableConnection();return t.clear()}static setLastInsert(t){var e=this.getTableName();l[e]=t}static getLastInsert(){var t=this.getTableName();return l[t]}static setTableConnection(t){this._connection=t}static getTableConnection(){if(!this._connection)throw"Table connection is not set. Do this with the setTableConnection method";return this._connection}static getQueryBuilder(){const t=this.getTableConnection();return new c(t)}static query(){return this.getQueryBuilder()}static getSchema(){return[]}static getColumns(){let t=this.getTableConnection();if(!t)return[];let e=[t.schema.primKey.name];return t.schema.indexes.map(r=>{r.compound||e.push(r.name)}),e}static setTableName(t){this.tableName=t}static getTableName(){return this.tableName}static getNumberValue(t){return typeof t=="number"?t:typeof t=="boolean"?t?1:0:typeof t=="string"?Number(t):isNaN(t)?0:Number(t)}};a.tableName="";let u=a;export{u as Model};
